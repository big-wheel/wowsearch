<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<div class="RichText ztext Post-RichText"><p><b>关于我</b>：<br>儿葱，25岁，工作 3 年半，在百度工作 3 年，现在美团任职，对于 Node.js Web React 方向比较熟悉。Github: imcuttle   邮箱: <a href="mailto:imcuttle@163.com">imcuttle@163.com</a></p><hr><p>下面进入正题，我将从一个实际的问题场景出发，层层讲诉 React 中 Mobx 和 Redux 的原理和对比。</p><p>在业务开发中，我们经常会需要开发一些复杂组件，其中不仅包括交互的复杂，也包括涉及到的数据结构复杂，如书写一个无限层级的树组件，其中的复杂度包括但不限于：</p><ul><li>数据嵌套递归逻辑</li><li>各个节点更新渲染的逻辑处理</li><li>节点渲染性能的考量</li></ul><p>以一个我碰到的实际业务场景为例：需要开发一个将 markdown文本渲染成 html 元素的组件。</p><h2>设计考虑</h2><p>大部分比较快速的实现方式比较简单，将 markdown 转换成 html 文本，然后使用 dangerouslySetInnerHTML 渲染 html 文本。</p><p>这种方式比较快捷，但是<b>没有模块化、不方便注入交互逻辑</b>。如需支持允许外部控制渲染各个 markdown 语法类型的结构体，这种方式不能够满足。</p><div class="highlight"><pre><code class="language-js"><span class="kr">const</span> <span class="nx">MarkdownView</span> <span class="o">=</span> <span class="p">({</span><span class="nx">markdown</span><span class="p">})</span> <span class="p">=&gt;</span> <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"markdown-body"</span> <span class="nx">dangerouslySetInnerHTML</span><span class="o">=</span><span class="p">{{</span><span class="nx">__html</span><span class="o">:</span> <span class="nx">marked</span><span class="p">(</span><span class="nx">markdown</span><span class="p">)}}</span> <span class="o">/&gt;</span>
</code></pre></div><hr><p>所以这时候就应该设计成<b>结构化渲染 </b>markdown，如使用 <a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/remark" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">remark</a> 将 markdown 解析成为 <a href="https://link.zhihu.com/?target=https%3A//github.com/syntax-tree/mdast" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">Markdown AST</a> (Abstract Syntax Tree 抽象语法树)</p><p>如以下 markdown 文本：</p><div class="highlight"><pre><code class="language-abap"><span class="err">##</span> <span class="nv">Header</span>
<span class="o">&gt;</span> <span class="k">Alpha</span> <span class="nv">bravo</span> <span class="nv">charlie</span><span class="p">.</span></code></pre></div><p>将会解析成如下 MD AST</p><div class="highlight"><pre><code class="language-text">[
  {
    type: 'heading',
    depth: 1,
    children: [{type: 'text', value: 'Header'}]
  },
  {
    type: 'blockquote',
    children: [{
      type: 'paragraph',
      children: [{type: 'text', value: 'Alpha bravo charlie.'}]
    }]
  }
]</code></pre></div><p>然后，我们只需要通过渲染 MD AST 即可</p><div class="highlight"><pre><code class="language-js"><span class="kr">import</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s2">"react"</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">renderers</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">heading</span><span class="o">:</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="p">{</span> <span class="nx">depth</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">node</span><span class="p">;</span>
    <span class="kr">const</span> <span class="nx">tagName</span> <span class="o">=</span> <span class="sb">`h</span><span class="si">${</span><span class="nx">depth</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="nx">tagName</span><span class="p">,</span> <span class="p">{},</span> <span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">);</span>
  <span class="p">},</span>
  <span class="nx">paragraph</span><span class="o">:</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/p&gt;,</span>
  <span class="nx">blockquote</span><span class="o">:</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="o">&lt;</span><span class="nx">blockquote</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/blockquote&gt;,</span>
  <span class="nx">text</span><span class="o">:</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/span&gt;</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">renderNode</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">Comp</span> <span class="o">=</span> <span class="nx">renderers</span><span class="p">[</span><span class="nx">node</span><span class="p">.</span><span class="nx">type</span><span class="p">];</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Comp</span> <span class="p">{...</span><span class="nx">props</span><span class="p">}</span> <span class="nx">node</span><span class="o">=</span><span class="p">{</span><span class="nx">node</span><span class="p">}</span><span class="o">&gt;</span>
      <span class="p">{(</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[]).</span><span class="nx">map</span><span class="p">((</span><span class="nx">childNode</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="nx">renderNode</span><span class="p">(</span><span class="nx">childNode</span><span class="p">,</span> <span class="p">{</span> <span class="nx">parent</span><span class="o">:</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">index</span> <span class="p">})</span>
      <span class="p">)}</span>
    <span class="o">&lt;</span><span class="err">/Comp&gt;</span>
  <span class="p">);</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">MarkdownView</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">mdast</span> <span class="p">})</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s2">"markdown-body"</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="o">!!</span><span class="nx">mdast</span> <span class="o">&amp;&amp;</span> <span class="nx">mdast</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">node</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">renderNode</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="p">{</span> <span class="nx">key</span><span class="o">:</span> <span class="nx">i</span> <span class="p">}))}</span>
    <span class="o">&lt;</span><span class="err">/div&gt;</span>
  <span class="p">);</span>
<span class="p">};</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">MarkdownView</span><span class="p">;</span>
</code></pre></div><p>以上一段剪短的代码就是简单的实现，但是这段代码只是功能正确，在遇到大体量的 MDAST，同时涉及到 MDAST 更新渲染的时候，该 MarkdownView 性能较低。</p><p>优化组件的更新渲染性能，我们从以下 2 个点展开：</p><ol><li>理清 React 的单向数据流和组件更新模式</li><li>优化更新性能</li><ol><li>immutable 操作</li><li>细化更新颗粒度</li><li>善于用 shouldComponentUpdate</li><li>mobx?<br>mutable 操作</li></ol></ol><hr><h3>React 单向数据流和组件更新模式</h3><p>以 MarkdownView 为例，MarkdownView 组件接收 mdast 数据，随后通过 props 传递给各 renderer 组件，这种从父组件传递数据到子组件的模式是<b>单向数据流</b>。</p><div class="highlight"><pre><code class="language-text">  &lt;MarkdownView&gt;  # 将 props 分发下去
    \          \
    &lt;heading&gt;   &lt;text&gt;</code></pre></div><p>由于这种模式是从上往下的数据传递，如涉及到子组件的更新，一般需要通过父组件数据改变而触发，也就是外部的 Props 修改来驱动更新；</p><p>如下代码，实现了点击 text 文本后，更新渲染为 input，用于更新 text.value：</p><div class="highlight"><pre><code class="language-js"><span class="kr">const</span> <span class="nx">Text</span> <span class="o">=</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="p">[</span><span class="nx">editing</span><span class="p">,</span> <span class="nx">setEditing</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
  <span class="kr">const</span> <span class="p">[</span><span class="nx">value</span><span class="p">,</span> <span class="nx">setValue</span><span class="p">]</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useState</span><span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
  <span class="nx">React</span><span class="p">.</span><span class="nx">useEffect</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="nx">setValue</span><span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">props</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">]);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">editing</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">input</span>
        <span class="nx">autoFocus</span>
        <span class="nx">onBlur</span><span class="o">=</span><span class="p">{()</span> <span class="p">=&gt;</span> <span class="p">{</span>
          <span class="nx">setEditing</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
          <span class="c1">// 注意这里
</span><span class="c1"></span>          <span class="nx">props</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="p">}}</span>
        <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="nx">value</span><span class="p">}</span>
        <span class="nx">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">setValue</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span>
      <span class="o">/&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">span</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="p">=&gt;</span> <span class="nx">setEditing</span><span class="p">(</span><span class="kc">true</span><span class="p">)}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">value</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/span&gt;;</span>
<span class="p">};</span>
</code></pre></div><p>具体代码见如下中的 mutable 模式：</p><a target="_blank" href="https://link.zhihu.com/?target=https%3A//codesandbox.io/s/markdown-view-9b7yq%3Ffile%3D/src/App.js" data-draft-node="block" data-draft-type="link-card" class="LinkCard LinkCard--noImage" data-za-detail-view-id="172"><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">https://codesandbox.io/s/markdown-view-9b7yq?file=/src/App.js</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">&#8203;<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>codesandbox.io</span></span><span class="LinkCard-imageCell"><div class="LinkCard-image LinkCard-image--default"><svg class="Zi Zi--Browser" fill="currentColor" viewBox="0 0 24 24" width="32" height="32"><path d="M11.991 3C7.023 3 3 7.032 3 12s4.023 9 8.991 9C16.968 21 21 16.968 21 12s-4.032-9-9.009-9zm6.237 5.4h-2.655a14.084 14.084 0 0 0-1.242-3.204A7.227 7.227 0 0 1 18.228 8.4zM12 4.836A12.678 12.678 0 0 1 13.719 8.4h-3.438A12.678 12.678 0 0 1 12 4.836zM5.034 13.8A7.418 7.418 0 0 1 4.8 12c0-.621.09-1.224.234-1.8h3.042A14.864 14.864 0 0 0 7.95 12c0 .612.054 1.206.126 1.8H5.034zm.738 1.8h2.655a14.084 14.084 0 0 0 1.242 3.204A7.188 7.188 0 0 1 5.772 15.6zm2.655-7.2H5.772a7.188 7.188 0 0 1 3.897-3.204c-.54.999-.954 2.079-1.242 3.204zM12 19.164a12.678 12.678 0 0 1-1.719-3.564h3.438A12.678 12.678 0 0 1 12 19.164zm2.106-5.364H9.894A13.242 13.242 0 0 1 9.75 12c0-.612.063-1.215.144-1.8h4.212c.081.585.144 1.188.144 1.8 0 .612-.063 1.206-.144 1.8zm.225 5.004c.54-.999.954-2.079 1.242-3.204h2.655a7.227 7.227 0 0 1-3.897 3.204zm1.593-5.004c.072-.594.126-1.188.126-1.8 0-.612-.054-1.206-.126-1.8h3.042c.144.576.234 1.179.234 1.8s-.09 1.224-.234 1.8h-3.042z"></path></svg></div></span></span></a><p>效果是，blur 之后修改的 value 是可以渲染出来的，但是如果我们把代码修改成如下：</p><div class="highlight"><pre><code class="language-text">onBlur={() =&gt; {
  setEditing(false);
  // 注意这里
  requestAnimationFrame(() =&gt; {
    props.node.value = value;
  })
}}</code></pre></div><p>结果 value 不能被同步渲染出来，这是因为 </p><div class="highlight"><pre><code class="language-text">props.node.value = value;</code></pre></div><p>这种 <b>mutable</b> 操作，不能够触发组件的更新，而第一个例子之所以能够起效果，是因为 onBlur 中 setEditing(false) 触发更新是异步的，React 会进行批更新优化，这个话题后续有空可以细谈。</p><p>什么 mutable 操作呢？如下：</p><div class="highlight"><pre><code class="language-js"><span class="kr">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">'John'</span> <span class="p">}</span>
<span class="c1">// mutable 操作，执行后，ref 引用未发生改变
</span><span class="c1"></span><span class="nx">ref</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'Tom'</span>
<span class="c1">// immutable 操作，执行后，ref 引用发生改变
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">newRef</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">ref</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">'Tom'</span> <span class="p">}</span>
</code></pre></div><p>也就是说在修改完 props.node.value 后，才触发 render 更新，所以可以生效；而 requestAnimationFrame 导致 props.node.value 修改发生在 render 之后；</p><p>基于 React 单向数据流原理，那么正确的 React 代码书写应该是如何的呢？</p><hr><h3>正确的基于 React 单向数据流的代码</h3><p>根据 React 单向数据流原理，应该修改最外层的 mdast，然后从上向下的触发子组件渲染，如下父子组件渲染关系：</p><div class="highlight"><pre><code class="language-text">     A
   /   \
  B     C
 / \     \
D   E     F</code></pre></div><p>MDAST 修改后，A 组件渲染驱动 B / C，B 驱动 D / E，C 驱动 F；但是这样也会带来一个问题：每一次 MDAST 修改，A 组件触发渲染，都会导致所有子组件进行渲染更新，对于比较庞大的组件树来说，效率低。</p><p>所以 React 引入了 <b>shouldComponentUpdate</b> 生命周期，下文用 scu 代替</p><p>在 MDAST 修改后，A 组件触发 scu，判断 A 组件可以 render 之后，B / C 组件触发 scu，依次进行下去。</p><p>所以为了提升效率，一般都会浅比较：新旧的 props 和 state， 来判断是否需要进行更新。因此一般会使用 <a href="https://link.zhihu.com/?target=https%3A//immutable-js.github.io/immutable-js/" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">immutable.js</a> 或 <a href="https://link.zhihu.com/?target=https%3A//github.com/immerjs/immer" class=" wrap external" target="_blank" rel="nofollow noreferrer" data-za-detail-view-id="1043">immer</a> 来对数据进行更新，但是最小程度的修改引用；</p><p>如下图，演示的是 immutable 库修改数据所做的事情：</p><figure data-size="normal"><noscript><img src="https://pic3.zhimg.com/v2-48f36e14328fa00acaf2f77cf02ab92a_b.gif" data-caption="" data-size="normal" data-rawwidth="613" data-rawheight="575" data-thumbnail="https://pic3.zhimg.com/v2-48f36e14328fa00acaf2f77cf02ab92a_b.jpg" class="origin_image zh-lightbox-thumb" width="613" data-original="https://pic3.zhimg.com/v2-48f36e14328fa00acaf2f77cf02ab92a_r.jpg"/></noscript><div class="RichText-gifPlaceholder"><div class="GifPlayer" data-size="normal" data-za-detail-view-path-module="GifItem"><img class="ztext-gif" role="presentation" src="https://pic3.zhimg.com/v2-48f36e14328fa00acaf2f77cf02ab92a_b.jpg" data-thumbnail="https://pic3.zhimg.com/v2-48f36e14328fa00acaf2f77cf02ab92a_b.jpg" data-size="normal"><svg width="60" height="60" viewBox="0 0 60 60" class="GifPlayer-icon"><g fill="none" fill-rule="evenodd"><ellipse fill="#000" opacity="0.45" cx="30" cy="30" rx="30" ry="30"></ellipse><ellipse stroke="#FFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="4,1,4" cx="30" cy="30" rx="26" ry="26"></ellipse><svg x="16" y="18.5" class="GifPlayer-icon"><path d="M12.842 12.981V11.4H7.64v1.653h3.27v.272c-.018 1.881-1.442 3.147-3.516 3.147-2.382 0-3.876-1.846-3.876-4.834 0-2.936 1.485-4.79 3.832-4.79 1.732 0 2.936.835 3.428 2.364h1.977c-.43-2.566-2.522-4.201-5.405-4.201-3.55 0-5.845 2.601-5.845 6.644 0 4.096 2.268 6.654 5.863 6.654 3.322 0 5.475-2.083 5.475-5.327zM17.518 18V5.317H15.55V18h1.97zm5.142 0v-5.256h5.449v-1.74h-5.45V7.11h5.95V5.317h-7.918V18h1.969z" fill="#fff"></path></svg></g></svg></div></div></figure><p>可以看到对于一个深层嵌套的数据，修改黄色节点，会导致其祖先节点引用的修改，但其他节点引用都不会修改。</p><p>这样对应在组件中，每次修改节点数据，导致根组件数据改变，进而触发单向数据流渲染，对于已经书写妥当 scu 的组件，其相关的数据只要没有发生改变，是不会触发渲染更新的，减少不必要的渲染更新，提高性能，具体可以参考下例中的 immutable 模式</p><a target="_blank" href="https://link.zhihu.com/?target=https%3A//codesandbox.io/s/markdown-view-9b7yq%3Ffile%3D/src/App.js" data-draft-node="block" data-draft-type="link-card" data-image="https://pic3.zhimg.com/v2-9f544578a965ee902d7ea6b8237d0f96_180x120.jpg" data-image-width="1200" data-image-height="630" class="LinkCard LinkCard--hasImage" data-za-detail-view-id="172"><span class="LinkCard-backdrop" style="background-image:url(https://pic3.zhimg.com/v2-9f544578a965ee902d7ea6b8237d0f96_180x120.jpg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">markdown-view - CodeSandbox</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">&#8203;<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>codesandbox.io</span></span><span class="LinkCard-imageCell"><img class="LinkCard-image LinkCard-image--horizontal" alt="图标" src="https://pic3.zhimg.com/v2-9f544578a965ee902d7ea6b8237d0f96_180x120.jpg"></span></span></a><p> 对于单向数据流渲染更新，需要注意：</p><ol><li>一个 react 组件才有自己的特定生命周期。如果对于MarkdownView 组件中各个节点数据的渲染统一都是通过一个个的方法体渲染，是不会<b>提高更新颗粒度</b>的，所以需要尽量多的拆分组件。</li><li>错误的 scu 书写会导致渲染更新错误</li></ol><p>那么基于单向数据流的更新渲染，有没有它的问题存在呢？</p><p>答案是有的，随着数据量的增加，嵌套深度增加，每一次的底层组件数据修改，都会回溯到根组件的更新，每一次更新渲染也需要不断的 scu 和从父到子的 render ，即使是在 react diff 、react fiber 的优化下，还是会有对应的瓶颈出现。那么有没有一种不需要回溯渲染的方式呢？</p><p>答案依然是有的。</p><h2>终极杀招 Mobx</h2><p>使用 mobx 可以避免父到子的回溯渲染，如下例子中的 mutable mobx 模式</p><a target="_blank" href="https://link.zhihu.com/?target=https%3A//codesandbox.io/s/markdown-view-9b7yq%3Ffile%3D/src/App.js" data-draft-node="block" data-draft-type="link-card" data-image="https://pic3.zhimg.com/v2-159515a86f756268f64300c80bb5a5be_180x120.jpg" data-image-width="1200" data-image-height="630" class="LinkCard LinkCard--hasImage" data-za-detail-view-id="172"><span class="LinkCard-backdrop" style="background-image:url(https://pic3.zhimg.com/v2-159515a86f756268f64300c80bb5a5be_180x120.jpg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">markdown-view - CodeSandbox</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">&#8203;<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>codesandbox.io</span></span><span class="LinkCard-imageCell"><img class="LinkCard-image LinkCard-image--horizontal" alt="图标" src="https://pic3.zhimg.com/v2-159515a86f756268f64300c80bb5a5be_180x120.jpg"></span></span></a><p> mobx react 的更新渲染机制于官方的单向数据触发的渲染不同，mobx 会将 mdast 变成一个被观察的数据，在每一次 mutable 修改中，都会被观察到数据的改动。</p><p>一旦在发现同步渲染所访问到的数据发生改动，就会主动的触发组件的更新，如 forceUpdate，这样一来 mutable 的操作修改，只会影响到使用了该数据的组件，这些组件进行主动的更新，而不会回溯进行父到子的更新渲染，大大减少了不必要的 suc 和 render</p><h2>总结</h2><p>综上，需要书写一个高性能的复杂组件，需要考虑的点颇多，最终有两种方式可供大家选择：</p><ol><li>基于 immutable 库和单向数据流 和 适量的组件拆分、scu 的书写来实现被动的更新。如 slate.js 的实现</li><li>基于 mobx 和适量的 observer 组件单元 来实现组件自驱的更新</li></ol><p>后面贴一个其他同学做的测试数据，可以看到 <b>mobx 性能更佳</b></p><a target="_blank" href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/kwzm/p/9889798.html" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-63c2bd4e2956fc36a6fa10eb3a45692d_180x120.jpg" data-image-width="371" data-image-height="213" class="LinkCard LinkCard--hasImage" data-za-detail-view-id="172"><span class="LinkCard-backdrop" style="background-image:url(https://pic2.zhimg.com/v2-63c2bd4e2956fc36a6fa10eb3a45692d_180x120.jpg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">redux、immutablejs和mobx性能对比（三） - 渴望做梦 - 博客园</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">&#8203;<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>www.cnblogs.com</span></span><span class="LinkCard-imageCell"><img class="LinkCard-image LinkCard-image--horizontal" alt="图标" src="https://pic2.zhimg.com/v2-63c2bd4e2956fc36a6fa10eb3a45692d_180x120.jpg"></span></span></a><p></p></div>
</body>
</html>
